import argparse
import json
import os
import subprocess
import tempfile
from datetime import datetime
from pathlib import Path


class WikiUpdater:
    def __init__(self, token, repo):
        self.token = token
        self.repo = repo
        self.wiki_url = f"https://x-access-token:{token}@github.com/{repo}.wiki.git"

    def clone_wiki(self, temp_dir):
        """Clone the wiki repository"""
        wiki_path = temp_dir / "wiki"
        try:
            subprocess.run([
                "git", "clone", self.wiki_url, str(wiki_path)
            ], check=True, capture_output=True)
        except subprocess.CalledProcessError:
            # Wiki might not exist yet, create it
            wiki_path.mkdir()
            os.chdir(wiki_path)
            subprocess.run(["git", "init"], check=True)
            subprocess.run(["git", "remote", "add", "origin", self.wiki_url], check=True)

        os.chdir(wiki_path)
        subprocess.run(["git", "config", "user.name", "github-actions[bot]"], check=True)
        subprocess.run(["git", "config", "user.email", "github-actions[bot]@users.noreply.github.com"], check=True)

        return wiki_path

    def get_commit_info(self, commit_hash, repo_path=None):
        """Get commit information from the specified repository path"""
        original_cwd = os.getcwd()

        try:
            # Change to the repository path if provided
            if repo_path:
                os.chdir(repo_path)

            result = subprocess.run([
                "git", "log", "-1", "--format=%H|%h|%an|%s|%ci", commit_hash
            ], capture_output=True, text=True, check=True)

            full_hash, short_hash, author, message, date = result.stdout.strip().split("|", 4)
            return {
                "full_hash": full_hash,
                "short_hash": short_hash,
                "author": author,
                "message": message,
                "date": date
            }
        finally:
            # Always restore the original working directory
            os.chdir(original_cwd)

    def read_json_file(self, file_path):
        """Read and parse JSON file"""
        if not file_path or not os.path.exists(file_path):
            return {}

        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except (json.JSONDecodeError, FileNotFoundError):
            return {}

    def create_changelog_page(self, commit_info, changelog_content):
        """Create changelog page"""
        short_hash = commit_info["short_hash"]
        date_str = datetime.now().strftime("%Y%m%d")

        content = f"""# Changelog: {short_hash}

**Commit:** [{short_hash}](https://github.com/{self.repo}/commit/{commit_info['full_hash']})  
**Date:** {commit_info['date']}
**Message:** {commit_info['message']}

## üìù Generated Changelog

{changelog_content}

---
*Auto-generated by GitHub Actions on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*
"""

        file_path = f"Changelog-{date_str}-{short_hash}.md"
        with open(file_path, 'w') as f:
            f.write(content)

        return file_path

    def create_code_review_page(self, commit_info, code_review_content):
        """Create code review page"""
        short_hash = commit_info["short_hash"]
        date_str = datetime.now().strftime("%Y%m%d")

        content = f"""# Code Review: {short_hash}

**Commit:** [{short_hash}](https://github.com/{self.repo}/commit/{commit_info['full_hash']})  
**Date:** {commit_info['date']}
**Message:** {commit_info['message']}

## üîç Code Review Analysis

{code_review_content}

---
*Auto-generated by GitHub Actions on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*
"""

        file_path = f"Review-{date_str}-{short_hash}.md"
        with open(file_path, 'w') as f:
            f.write(content)

        return file_path

    def create_failure_page(self, commit_info, error_analysis_content, run_id):
        """Create failed build documentation page"""
        short_hash = commit_info["short_hash"]
        date_str = datetime.now().strftime("%Y%m%d")

        content = f"""# Build Failure Analysis: {short_hash}

**Commit:** [{short_hash}](https://github.com/{self.repo}/commit/{commit_info['full_hash']})  
**Date:** {commit_info['date']}
**Author:** {commit_info['author']}  
**Message:** {commit_info['message']}  
**Status:** ‚ùå Build Failed

## üö® Error Analysis

{error_analysis_content}

## üîó Links
- [View Commit](https://github.com/{self.repo}/commit/{commit_info['full_hash']})
- [GitHub Actions Run](https://github.com/{self.repo}/actions/runs/{run_id})

---
*Auto-generated by GitHub Actions on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*
"""

        file_path = f"Failure-{date_str}-{short_hash}.md"
        with open(file_path, 'w') as f:
            f.write(content)

        return file_path

    def parse_existing_sidebar(self):
        """Parse existing _Sidebar.md file to extract entries by date"""
        sidebar_file = "_Sidebar.md"
        if not os.path.exists(sidebar_file):
            return {"changelogs": {}, "reviews": {}, "failures": {}}

        entries = {"changelogs": {}, "reviews": {}, "failures": {}}

        try:
            with open(sidebar_file, 'r') as f:
                content = f.read()

            current_section = None
            current_date = None

            for line in content.split('\n'):
                line = line.strip()
                if line.startswith('**Changelogs**'):
                    current_section = "changelogs"
                elif line.startswith('**Code Reviews**'):
                    current_section = "reviews"
                elif line.startswith('**Failed Builds**'):
                    current_section = "failures"
                elif line.startswith('*') and line.endswith('*') and current_section:
                    # This is a date header
                    current_date = line.strip('*').strip()
                    if current_date not in entries[current_section]:
                        entries[current_section][current_date] = []
                elif line.startswith('* ') and current_section and current_date:
                    # This is an entry
                    entries[current_section][current_date].append(line)
        except Exception:
            # If parsing fails, return empty structure
            pass

        return entries

    def update_sidebar(self, commit_info, changelog_path=None, code_review_path=None, failure_path=None):
        """Update the _Sidebar.md file with new entries"""
        existing_entries = self.parse_existing_sidebar()

        # Get date for grouping
        commit_date = datetime.fromisoformat(commit_info['date'].replace('Z', '+00:00'))
        date_str = commit_date.strftime("%Y-%m-%d")

        # Add new entries (remove .md extension for proper wiki linking)
        if changelog_path:
            if date_str not in existing_entries["changelogs"]:
                existing_entries["changelogs"][date_str] = []
            wiki_link = changelog_path.replace('.md', '')
            entry = f"* [{commit_info['short_hash']} - {commit_info['message'][:50]}...]({wiki_link})"
            existing_entries["changelogs"][date_str].insert(0, entry)  # Add to beginning

        if code_review_path:
            if date_str not in existing_entries["reviews"]:
                existing_entries["reviews"][date_str] = []
            wiki_link = code_review_path.replace('.md', '')
            entry = f"* [{commit_info['short_hash']} - {commit_info['message'][:50]}...]({wiki_link})"
            existing_entries["reviews"][date_str].insert(0, entry)  # Add to beginning

        if failure_path:
            if date_str not in existing_entries["failures"]:
                existing_entries["failures"][date_str] = []
            wiki_link = failure_path.replace('.md', '')
            entry = f"* [{commit_info['short_hash']} - {commit_info['message'][:50]}...‚ùå]({wiki_link})"
            existing_entries["failures"][date_str].insert(0, entry)  # Add to beginning

        # Build the sidebar content
        sidebar_content = "## **Semo**\n\n"

        # Changelogs section
        sidebar_content += "**Changelogs**\n\n"
        for date in sorted(existing_entries["changelogs"].keys(), reverse=True):
            sidebar_content += f"*{date}*\n\n"
            for entry in existing_entries["changelogs"][date]:
                sidebar_content += f"{entry}\n"
            sidebar_content += "\n"

        # Code Reviews section
        sidebar_content += "**Code Reviews**\n\n"
        for date in sorted(existing_entries["reviews"].keys(), reverse=True):
            sidebar_content += f"*{date}*\n\n"
            for entry in existing_entries["reviews"][date]:
                sidebar_content += f"{entry}\n"
            sidebar_content += "\n"

        # Failed Builds section
        sidebar_content += "**Failed Builds**\n\n"
        for date in sorted(existing_entries["failures"].keys(), reverse=True):
            sidebar_content += f"*{date}*\n\n"
            for entry in existing_entries["failures"][date]:
                sidebar_content += f"{entry}\n"
            sidebar_content += "\n"

        # Write the sidebar file
        with open("_Sidebar.md", 'w') as f:
            f.write(sidebar_content)

    def update_home_page(self, commit_info, changelog_path=None, code_review_path=None, failure_path=None):
        """Update or create the home page"""
        home_file = "Home.md"

        if failure_path:
            # Failed build
            wiki_link = failure_path.replace('.md', '')
            latest_link = f"- [Latest Build (Failed)]({wiki_link}) - {commit_info['short_hash']} ‚ùå"
        else:
            # Successful build
            changelog_wiki_link = changelog_path.replace('.md', '') if changelog_path else '#'
            code_review_wiki_link = code_review_path.replace('.md', '') if code_review_path else '#'
            latest_link = f"""
- [Latest Changelog]({changelog_wiki_link}) - {commit_info['short_hash']}
- [Latest Code Review]({code_review_wiki_link}) - {commit_info['short_hash']}
"""

        content = f"""# Semo Project Documentation

Welcome to the Semo project documentation wiki!

## üìã Latest Updates
{latest_link}

## üìÅ Documentation Structure
All documentation is organized in the sidebar by type and date:
- **Changelogs** - Generated changelogs for each commit
- **Code Reviews** - Automated code review summaries  
- **Failed Builds** - Build failure analyses

---
*Last updated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*
"""

        with open(home_file, 'w') as f:
            f.write(content)

    def commit_and_push(self, commit_info, is_success=True):
        """Commit and push changes to wiki"""
        status_text = "success" if is_success else "failure"
        commit_message = f"Add {status_text} documentation for commit {commit_info['short_hash']}: {commit_info['message']}"

        subprocess.run(["git", "add", "."], check=True)

        # Check if there are changes to commit
        result = subprocess.run(["git", "diff", "--staged", "--quiet"], capture_output=True)
        if result.returncode == 0:
            print("No changes to commit")
            return

        subprocess.run(["git", "commit", "-m", commit_message], check=True)

        # Check which branch we're on and push to that branch
        result = subprocess.run(["git", "branch", "--show-current"],
                                capture_output=True, text=True, check=True)
        current_branch = result.stdout.strip()

        if current_branch:
            # Push to the current branch
            subprocess.run(["git", "push", "origin", current_branch], check=True)
        else:
            # Fallback: try master first, then main
            try:
                subprocess.run(["git", "push", "origin", "master"], check=True)
            except subprocess.CalledProcessError:
                subprocess.run(["git", "push", "origin", "main"], check=True)

    def handle_success(self, commit_hash, changelog_file, code_review_file):
        """Handle successful build documentation"""
        # Store the original repository path before any directory changes
        original_repo_path = os.getcwd()

        # Get commit info from the original repository first
        commit_info = self.get_commit_info(commit_hash, original_repo_path)

        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            wiki_path = self.clone_wiki(temp_path)

            # Read generated content (these files should be in the original repo path)
            changelog_data = self.read_json_file(os.path.join(original_repo_path, changelog_file) if changelog_file else None)
            code_review_data = self.read_json_file(os.path.join(original_repo_path, code_review_file) if code_review_file else None)

            changelog_content = changelog_data.get('changelog', 'No changelog generated')
            code_review_content = code_review_data.get('code_review', 'No code review generated')

            # Create separate pages
            changelog_path = self.create_changelog_page(commit_info, changelog_content)
            code_review_path = self.create_code_review_page(commit_info, code_review_content)

            # Update sidebar and home page
            self.update_sidebar(commit_info, changelog_path, code_review_path)
            self.update_home_page(commit_info, changelog_path, code_review_path)

            # Commit and push
            self.commit_and_push(commit_info, is_success=True)

            print(f"Successfully updated wiki for commit {commit_info['short_hash']}")

    def handle_failure(self, commit_hash, error_analysis_file, run_id):
        """Handle failed build documentation"""
        # Store the original repository path before any directory changes
        original_repo_path = os.getcwd()

        # Get commit info from the original repository first
        commit_info = self.get_commit_info(commit_hash, original_repo_path)

        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            wiki_path = self.clone_wiki(temp_path)

            # Read error analysis (this file should be in the original repo path)
            error_data = self.read_json_file(os.path.join(original_repo_path, error_analysis_file) if error_analysis_file else None)
            error_content = error_data.get('error_analysis', 'Build failed but no error analysis was generated.')

            # Create failure page
            failure_path = self.create_failure_page(commit_info, error_content, run_id)

            # Update sidebar and home page
            self.update_sidebar(commit_info, failure_path=failure_path)
            self.update_home_page(commit_info, failure_path=failure_path)

            # Commit and push
            self.commit_and_push(commit_info, is_success=False)

            print(f"Successfully updated wiki with failure analysis for commit {commit_info['short_hash']}")


def main():
    parser = argparse.ArgumentParser(description='Update GitHub wiki with build documentation')
    parser.add_argument('--token', required=True, help='GitHub token')
    parser.add_argument('--repo', required=True, help='Repository name (owner/repo)')
    parser.add_argument('--commit-hash', required=True, help='Commit hash')
    parser.add_argument('--run-id', help='GitHub Actions run ID (for failures)')

    # File arguments
    parser.add_argument('--changelog-file', help='Path to changelog JSON file')
    parser.add_argument('--code-review-file', help='Path to code review JSON file')
    parser.add_argument('--error-analysis-file', help='Path to error analysis JSON file')

    # Mode arguments
    parser.add_argument('--success', action='store_true', help='Handle successful build')
    parser.add_argument('--failure', action='store_true', help='Handle failed build')

    args = parser.parse_args()

    updater = WikiUpdater(args.token, args.repo)

    if args.success:
        updater.handle_success(args.commit_hash, args.changelog_file, args.code_review_file)
    elif args.failure:
        updater.handle_failure(args.commit_hash, args.error_analysis_file, args.run_id)
    else:
        print("Must specify either --success or --failure")
        return 1

    return 0


if __name__ == "__main__":
    exit(main())